#!/usr/bin/env python3
"""
Agent Prompt Builder - Template assembler for agent invocation prompts.

This module ONLY assembles templates. All dynamic content (role extension,
research terms) is generated by the DA orchestrator and passed as parameters.

The template file is located at:
  .claude/orchestration/shared/templates/agent-system-prompt.md

Usage:
    builder = AgentPromptBuilder(
        task_id="...",
        skill_name="...",
        phase_id="...",
        agent_name="research",
        domain="technical",
        role_extension="[DA generates this]",
        research_terms="[DA generates this]",
        johari_findings={...},
        user_request="...",
    )
    prompt = builder.build()
"""

from __future__ import annotations

import sys
from pathlib import Path
from typing import Any, Dict, List, Optional

# Path setup - add protocols directory for fully-qualified imports
_CORE_DIR = Path(__file__).resolve().parent
_SKILL_PROTOCOLS_ROOT = _CORE_DIR.parent
_PROTOCOLS_DIR = _SKILL_PROTOCOLS_ROOT.parent
_ORCHESTRATION_ROOT = _PROTOCOLS_DIR.parent
_CLAUDE_ROOT = _ORCHESTRATION_ROOT.parent

if str(_PROTOCOLS_DIR) not in sys.path:
    sys.path.insert(0, str(_PROTOCOLS_DIR))

# Template path
TEMPLATE_DIR = _ORCHESTRATION_ROOT / "shared" / "templates"
TEMPLATE_FILE = TEMPLATE_DIR / "agent-system-prompt.md"


class AgentPromptBuilder:
    """
    Assemble agent prompts from template - NO content generation.

    The DA orchestrator is responsible for generating dynamic content:
    - role_extension: Task-specific focus areas
    - research_terms: Related search keywords

    This class only loads the template and substitutes provided values.
    """

    def __init__(
        self,
        task_id: str,
        skill_name: str,
        phase_id: str,
        agent_name: str,
        domain: str = "technical",
        context_pattern: str = "IMMEDIATE_PREDECESSORS",
        predecessors: Optional[List[str]] = None,
        phase_instructions: str = "",
        plan: Optional[Dict[str, Any]] = None,
        johari_findings: Optional[Dict[str, Any]] = None,
        user_request: str = "",
        role_extension: str = "",
        research_terms: str = "",
        requirements_list: str = "",
        constraints_list: str = "",
        config: Optional[Dict[str, Any]] = None,
    ):
        """
        Initialize the prompt builder.

        Args:
            task_id: Unique task identifier
            skill_name: Name of skill being executed
            phase_id: Current phase identifier
            agent_name: Agent to invoke
            domain: Task domain (technical, personal, creative, professional, recreational)
            context_pattern: How to load context (WORKFLOW_ONLY, IMMEDIATE_PREDECESSORS, MULTIPLE_PREDECESSORS)
            predecessors: List of predecessor agent names for context loading
            phase_instructions: Skill-specific instructions for this phase
            plan: Approved execution plan from reasoning protocol
            johari_findings: Johari findings from reasoning Step 0
            user_request: Original user request
            role_extension: Task-specific role specialization (DA generates)
            research_terms: Related search keywords (DA generates)
            requirements_list: Task requirements (DA generates)
            constraints_list: Task constraints (DA generates)
            config: Additional configuration parameters
        """
        self.task_id = task_id
        self.skill_name = skill_name
        self.phase_id = phase_id
        self.agent_name = agent_name
        self.domain = domain
        self.context_pattern = context_pattern
        self.predecessors = predecessors or []
        self.phase_instructions = phase_instructions
        self.plan = plan or {}
        self.johari_findings = johari_findings or {}
        self.user_request = user_request
        self.role_extension = role_extension
        self.research_terms = research_terms
        self.requirements_list = requirements_list
        self.constraints_list = constraints_list
        self.config = config or {}

    def build(self) -> str:
        """
        Load template and substitute all values.

        Returns:
            Complete agent prompt string
        """
        template = self._load_template()
        return self._substitute_values(template)

    def _load_template(self) -> str:
        """Load the markdown template file."""
        if not TEMPLATE_FILE.exists():
            # Fallback to inline template if file doesn't exist
            return self._get_fallback_template()
        return TEMPLATE_FILE.read_text()

    def _substitute_values(self, template: str) -> str:
        """
        Substitute all placeholder values in template.

        Uses simple string replacement - no templating engine required.
        """
        replacements = {
            "{{task_id}}": self.task_id,
            "{{skill_name}}": self.skill_name,
            "{{phase_id}}": self.phase_id,
            "{{domain}}": self.domain,
            "{{agent_name}}": self.agent_name,
            "{{role_extension}}": self.role_extension or "No task-specific role extension provided.",
            "{{johari_open}}": self._format_johari_quadrant("open"),
            "{{johari_blind}}": self._format_johari_quadrant("blind"),
            "{{johari_hidden}}": self._format_johari_quadrant("hidden"),
            "{{johari_unknown}}": self._format_johari_quadrant("unknown"),
            "{{user_request}}": self.user_request or "No user request provided.",
            "{{requirements_list}}": self.requirements_list or "No specific requirements provided.",
            "{{constraints_list}}": self.constraints_list or "No specific constraints provided.",
            "{{context_pattern}}": self.context_pattern,
            "{{predecessor_files}}": self._format_predecessor_files(),
            "{{plan_section}}": self._format_plan_section(),
            "{{phase_instructions}}": self.phase_instructions or "Execute standard cognitive function for this agent.",
            "{{memory_file_path}}": f".claude/memory/{self.task_id}-{self.agent_name}-memory.md",
            "{{related_research_terms}}": self.research_terms or "No specific research terms provided.",
        }

        result = template
        for placeholder, value in replacements.items():
            result = result.replace(placeholder, str(value))

        return result.strip()

    def _format_johari_quadrant(self, quadrant: str) -> str:
        """Format a single Johari quadrant."""
        if not self.johari_findings:
            return "No prior Johari analysis available."

        value = self.johari_findings.get(quadrant)
        if not value:
            return f"No {quadrant} findings available."

        if isinstance(value, dict):
            # Format dict as bullet points
            lines = []
            for key, val in value.items():
                if isinstance(val, list):
                    lines.append(f"- **{key}:** {', '.join(str(v) for v in val)}")
                else:
                    lines.append(f"- **{key}:** {val}")
            return "\n".join(lines) if lines else f"No {quadrant} findings available."
        elif isinstance(value, list):
            return "\n".join(f"- {item}" for item in value)
        else:
            return str(value)

    def _format_predecessor_files(self) -> str:
        """Format predecessor memory file paths."""
        memory_base = ".claude/memory"

        if self.context_pattern == "WORKFLOW_ONLY":
            return f"- `{memory_base}/{self.task_id}-workflow-metadata.md`"

        if not self.predecessors:
            return f"- `{memory_base}/{self.task_id}-workflow-metadata.md`\n- Check workflow state for actual predecessor."

        files = [f"- `{memory_base}/{self.task_id}-workflow-metadata.md`"]
        for pred in self.predecessors:
            files.append(f"- `{memory_base}/{self.task_id}-{pred}-memory.md`")

        return "\n".join(files)

    def _format_plan_section(self) -> str:
        """Format the approved execution plan section."""
        if not self.plan:
            return "No approved execution plan available."

        lines = []

        # Task summary
        task_summary = self.plan.get("task_summary", "")
        if task_summary:
            lines.append(f"**Task:** {task_summary}")

        # Understanding section
        understanding = self.plan.get("understanding", {})
        if understanding:
            goal = understanding.get("interpreted_goal", "")
            if goal:
                lines.append(f"**Goal:** {goal}")

            requirements = understanding.get("key_requirements", [])
            if requirements:
                lines.append("**Key Requirements:**")
                for req in requirements[:5]:
                    lines.append(f"- {req}")

        # Approach section
        approach = self.plan.get("approach", {})
        if approach:
            strategy = approach.get("strategy", "")
            if strategy:
                lines.append(f"**Strategy:** {strategy}")

            steps = approach.get("steps", [])
            if steps:
                lines.append("**Planned Steps:**")
                for step in steps[:6]:
                    step_num = step.get("step", "?")
                    action = step.get("action", "")
                    lines.append(f"{step_num}. {action}")

        # Success criteria
        criteria = self.plan.get("success_criteria", [])
        if criteria:
            lines.append("**Success Criteria:**")
            for c in criteria[:4]:
                lines.append(f"- {c}")

        # Risks
        risks = self.plan.get("risk_assessment", {}).get("potential_issues", [])
        if risks:
            lines.append("**Risks to Consider:**")
            for r in risks[:3]:
                lines.append(f"- {r}")

        if lines:
            lines.append("")
            lines.append("**Important:** Your output should align with and advance this approved plan.")

        return "\n".join(lines) if lines else "No approved execution plan available."

    def _get_fallback_template(self) -> str:
        """Provide a fallback template if the file doesn't exist."""
        return """# Agent Invocation: {{agent_name}}

## Task Context

- **Task ID:** `{{task_id}}`
- **Skill:** `{{skill_name}}`
- **Phase:** `{{phase_id}}`
- **Domain:** `{{domain}}`
- **Agent:** `{{agent_name}}`

## Role Extension

{{role_extension}}

## Prior Knowledge Context (Johari Window)

### Open
{{johari_open}}

### Blind
{{johari_blind}}

### Hidden
{{johari_hidden}}

### Unknown
{{johari_unknown}}

## User Request

{{user_request}}

### Requirements
{{requirements_list}}

### Constraints
{{constraints_list}}

## Context Loading

**Pattern:** {{context_pattern}}

**Files to Load:**
{{predecessor_files}}

## Execution Plan

{{plan_section}}

## Phase Instructions

{{phase_instructions}}

## Output Requirements

**Memory File:** `{{memory_file_path}}`
**Format:** Johari Window Structure

## Related Research Terms

{{related_research_terms}}

## Execution Protocol

1. Execute the agent entry script
2. Follow all step directives output by the scripts
3. Write memory file in Johari Window format before completion
4. Signal completion via the complete script
"""
